#! /usr/bin/perl
# ABSTRACT: Count reads based on a GFF/GTF annotation file
# PODNAME: cractools count

use strict;
use warnings;

use Getopt::Long qw(:config auto_version ); # Get options
use Carp;
use Pod::Usage;
use CracTools;
use CracTools::Utils; # For multi-purpose tasks
use CracTools::Annotator; # This help to index the annotation file for fast query
use CracTools::Output; # For printing output column-based file
use Data::Dumper; # Debugging purpose

=head1 SYNOPSIS

  cractools count [options] file.gff file.bam [file2.bam file3.bam]

=head1 OPTIONS

  --help                 Print this help
  --man                  Open man page
  -f                     Feature type to count
  -v|--verbose           Verbose mode
  -p=INT                 Number of process to run (default:1)

=cut  

my @ARGV_copy = @ARGV;

my ($help,
  $man,
  $verbose,
);

my $nb_process = 1;
my $feature_type = "exon";
my $is_stranded = 0;

GetOptions(
  "v|verbose"         => \$verbose,
  "p=i"               => \$nb_process,
  "man"               => \$man,
  "help"              => \$help,
  "f=s"               => \$feature_type,
  "stranded"          => \$is_stranded,
) or pod2usage(-verbose => 1);

# TODO implement is_stranded 

pod2usage(-verbose => 1)  if ($help);
pod2usage(-verbose => 2)  if ($man);

my $annot_file = shift @ARGV;
pod2usage(-verbose => 1)  unless defined $annot_file;

my $bam_file = shift @ARGV;
pod2usage(-verbose => 1)  unless defined $bam_file;

my $annotator = CracTools::Annotator->new($annot_file,"fast");
#my $annotator = CracTools::Annotator->new($annot_file);
print STDERR "Annotator created\n";

my $bam_it = CracTools::Utils::bamFileIterator($bam_file,"");

my %counts;

while(my $line = $bam_it->()) {
  my $sam_line = CracTools::Utils::parseSAMLineLite($line);

  # Find read chunks and register for each on of them a list of candidates
  my $low = $sam_line->{pos};
  my $high = $low;
  my $strand = $sam_line->{flag} & 16? -1 : 1;
  my @candidates;
  my $nb_chunk = 0;
  foreach my $cigar_chunk (@{$sam_line->{cigar}}) {
    if($cigar_chunk->{op} =~ 'N') {
      if($nb_chunk == 0) {
        # This chunk's end should be close to an exon end
        push(@candidates,getReadChunkCandidates($sam_line->{rname},$low,$high,$strand,\&compareSubExonEnd));
      } else {
        # This chunk's boundaries should correspond to an exon
        push(@candidates,getReadChunkCandidates($sam_line->{rname},$low,$high,$strand,\&compareSubExon));
      }
      $low = $high + $cigar_chunk->{nb};
      $high = $low;
      $nb_chunk++;
    } elsif($cigar_chunk->{op} !~ /[SHI]./) {
      $high = $high + $cigar_chunk->{nb};
    }
  }
  # Conting the last chunk
  # This chunk's start should correspond to an exon start
  push(@candidates,getReadChunkCandidates($sam_line->{rname},$low,$high,$strand,\&compareSubExonStart));
  
  my $min_dist;
  # First we init the hash of selected candidates for the first chunk
  my %selected_candidates;
  foreach my $first_chunk_cand (@{$candidates[0]}) {
    $selected_candidates{$first_chunk_cand->{$feature_type}->attribute('ID')} = $first_chunk_cand->{$feature_type};
  }
  # We loop over all chunk candidates to find the best annotation feater
  # by selecting those that have the same exons.
  for(my $i = 1; $i < @candidates -1; $i++) {
    my %current_selection;
    my $current_min_dist;# = $min_dist;
    # We do the intersection with the previous chunk
    foreach my $prev_cand (@{$candidates[$i-1]}) {
      my $prev_parent_feat = $feature_type;
      foreach my $curr_cand (@{$candidates[$i]}) {
        my $curr_parent_feat = $feature_type;
        my $dist = 0;
        # We declare a hash that stores "already seen features" in order
        # to avoid infinite loop.
        my %avoid_recurs;
        while(defined $prev_parent_feat && defined $curr_parent_feat &&
          $prev_cand->{$prev_parent_feat}->attribute('ID') ne $curr_cand->{$curr_parent_feat}->attribute('ID')) {
          $dist++;
          my $prev_parent_feat = $prev_cand->{parent_feature}->{$prev_parent_feat};
          my $curr_parent_feat = $curr_cand->{parent_feature}->{$curr_parent_feat};
          if(defined $avoid_recurs{$prev_parent_feat} || 
            defined $avoid_recurs{$curr_parent_feat}) {
            carp "GFF deep recursion\n";
            last;
          }
          $avoid_recurs{$prev_parent_feat} = 1;
          $avoid_recurs{$curr_parent_feat} = 1;
        }
        if(!defined $current_min_dist || $dist < $current_min_dist) {
          $current_min_dist = $dist;
          %current_selection = ();
        }
        if($dist == $current_min_dist) {
          $current_selection{$curr_cand->{$feature_type}->attribute('ID')} = $curr_cand->{$feature_type};
        }
      }
    }
    # If we have something in the current selection; that means that we have
    # found a good candidate(s)
    if(%current_selection && (!defined $min_dist || $current_min_dist == $min_dist)) {
      # We merge candidate hashes
      @selected_candidates{keys %current_selection} = values %current_selection;
    # If we do not, we need to count the read for the prev candidate(s)
    # and continue for next chunks to come
    } else {
      foreach my $candidate (keys %selected_candidates) {
        $counts{$candidate}++;
      }
      %selected_candidates = %current_selection;
    }
  }
  # We add to the count table what's left
  foreach my $candidate (keys %selected_candidates) {
    $counts{$candidate}++;
  }
}

# Now we print output
my $output = CracTools::Output->new();
$output->printHeaders(args => \@ARGV_copy);
foreach my $count_key (sort keys %counts) {
  $output->printLine($count_key,$counts{$count_key});
}

## SUBROUTINES

sub getReadChunkCandidates {
  my ($chr,$start,$end,$strand,$compareSub) = @_;
  my @potential_candidates;
  my @candidates;
  my $is_included = 0;
  if($is_stranded && defined $strand) {
    # TODO
  } else {
    foreach my $query_strand ((1,-1)) {
      my ($best_candidates) = $annotator->getBestAnnotationCandidates($chr,
          $start,
          $end,
          $query_strand,
          \&prioritySub, 
          $compareSub,
      );
      push @potential_candidates, @{$best_candidates};
    }
  }
  foreach my $candidate (@potential_candidates) {
    # First we want the candidate to have the feature type that we are
    # counting on
    if(defined $candidate->{$feature_type}) {
      # if candidate is included
      if($candidate->{$feature_type}->start >= $start && $candidate->{$feature_type}->end <= $end) {
        if(!$is_included) {
          @candidates = ();
          $is_included = 1;
        }
        push(@candidates,$candidate);
      } elsif(!$is_included) {
        push(@candidates,$candidate);
      }
    }
  }
  return \@candidates;
}

sub prioritySub {
  my ($pos_start,$pos_end,$candidate) = @_;
  my ($priority,$type) = (-1,'');
  my $exon = $candidate->{exon};
  if (defined $exon) {
    $priority = 1;
    $type = 'EXON';
  } else {
    $priority = 2;
    $type = 'NO_EXON';
  }
  return ($priority,$type);
}

# Return the candidate that is the closest to exon bounds
sub compareSubExon {
  my ($candidate1,$candidate2,$pos_start,$pos_end) = @_;
  # If both candidates are exons we try to find wich one is closer to the pos_start of the region to annotate
  if ($candidate1->{exon} && $candidate2->{exon}) { 
    my $dist1 = abs($candidate1->{exon}->start - $pos_start) + abs($candidate1->{exon}->end - $pos_end);
    my $dist2 = abs($candidate2->{exon}->start - $pos_start) + abs($candidate2->{exon}->end - $pos_end);
    if($dist1 < $dist2) {
      return $candidate1;
    } elsif($dist1 > $dist2) {
      return $candidate2;
    }
  }
  # If nothing has worked we return "undef"
  return undef;
}

# Return the candidate that is the closest to exon start bound
sub compareSubExonStart {
  my ($candidate1,$candidate2,$pos_start,$pos_end) = @_;
  # If both candidates are exons we try to find wich one is closer to the pos_start of the region to annotate
  if ($candidate1->{exon} && $candidate2->{exon}) { 
    my $dist1 = abs($candidate1->{exon}->start - $pos_start);
    my $dist2 = abs($candidate2->{exon}->start - $pos_start);
    if($dist1 < $dist2) {
      return $candidate1;
    } elsif($dist1 > $dist2) {
      return $candidate2;
    }
  }
  # If nothing has worked we return "undef"
  return undef;
}

# Return the candidate that is the closest to exon end bound
sub compareSubExonEnd {
  my ($candidate1,$candidate2,$pos_start,$pos_end) = @_;
  # If both candidates are exons we try to find wich one is closer to the pos_end of the region to annotate
  if ($candidate1->{exon} && $candidate2->{exon}) { 
    my $dist1 = abs($candidate1->{exon}->end - $pos_start);
    my $dist2 = abs($candidate2->{exon}->end - $pos_start);
    if($dist1 < $dist2) {
      return $candidate1;
    } elsif($dist1 > $dist2) {
      return $candidate2;
    }
  }
  # If nothing has worked we return "undef"
  return undef;
}
